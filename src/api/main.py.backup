"""
FastAPI backend for Drug Discovery - Complete 3-Step System
"""
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
import sys
from pathlib import Path
import traceback
import pandas as pd

# Add parent directory to path
sys.path.append(str(Path(__file__).parent.parent))

from database.vector_db_client import VectorDBClient
from embeddings.molecular_encoder import MolecularEncoder
from api.drug_analysis import analyze_structural_features, suggest_drug_scaffolds

app = FastAPI(title="Drug Discovery API", version="1.0.0")

# CORS middleware for frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize clients
client = VectorDBClient()
encoder = MolecularEncoder(method="morgan", dim=2048)

# Load drug dataset for analysis
try:
    drugs_df = pd.read_csv("data/drugs.csv")
    print(f"âœ“ Loaded {len(drugs_df)} drugs for analysis")
except Exception as e:
    print(f"âš  Could not load drugs.csv: {e}")
    drugs_df = pd.DataFrame()


# Pydantic models
class DrugSearchRequest(BaseModel):
    smiles: str
    top_k: int = 10


class DrugSearchByUseCaseRequest(BaseModel):
    use_case: str
    top_k: int = 10


class DrugResult(BaseModel):
    id: str
    name: str
    smiles: str
    similarity: float
    distance: float
    indication: Optional[str] = None


class DrugSearchResponse(BaseModel):
    query: str
    results: List[DrugResult]
    total_found: int
    search_time_ms: Optional[float] = None


class StructuralAnalysisResponse(BaseModel):
    total_molecules: int
    avg_molecular_weight: float
    avg_ring_count: float
    avg_aromatic_rings: float
    molecules_with_aromatic_rings: int
    molecules_with_multiple_rings: int
    common_features: Dict[str, Any]


class QueryDrug(BaseModel):
    name: str
    smiles: str


class ScaffoldSuggestionsRequest(BaseModel):
    query_drugs: List[QueryDrug]
    top_k: int = 5


class ScaffoldSuggestion(BaseModel):
    name: str
    smiles: str
    similarity_to_centroid: float
    indication: Optional[str] = None


class ScaffoldSuggestionsResponse(BaseModel):
    suggestions: List[ScaffoldSuggestion]
    description: str


# Endpoints

@app.get("/")
def root():
    return {
        "service": "Drug Discovery API - 3-Step System",
        "version": "1.0.0",
        "status": "running",
        "features": [
            "Step 1: Structure-based search",
            "Step 2: Structural analysis",
            "Step 3: Scaffold suggestions"
        ]
    }


@app.get("/health")
def health_check():
    """Check if backend and vector DB are healthy"""
    db_healthy = client.health_check()
    return {
        "api": "healthy",
        "vector_db": "healthy" if db_healthy else "unhealthy",
        "drugs_loaded": len(drugs_df) > 0
    }


@app.get("/stats")
def get_stats():
    """Get drug database statistics"""
    try:
        stats = client.get_stats("drugs")
        collections = client.list_collections()
        
        return {
            "collections": collections,
            "drugs_collection": stats,
            "drugs_in_csv": len(drugs_df)
        }
    except Exception as e:
        print(f"Error in /stats: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/search/structure", response_model=DrugSearchResponse)
def search_by_structure(request: DrugSearchRequest):
    """
    STEP 1: Search for drugs similar to a query molecule structure (SMILES)
    """
    try:
        import time
        print(f"\n[SEARCH] Received request: {request.smiles[:50]}... (top_k={request.top_k})")
        start = time.time()
        
        # Encode query molecule
        query_vector = encoder.encode(request.smiles)
        
        # Search in drugs collection
        results = client.search(
            query_vector=query_vector,
            top_k=request.top_k + 5,
            metric="cosine",
            collection="drugs"
        )
        
        # Convert to response format and filter
        drug_results = []
        for result in results:
            distance = result['score']
            similarity = 1 - distance
            
            # Skip if it's nearly identical (query drug itself)
            if distance < 0.01 or similarity > 0.99:
                continue
                
            drug_results.append(DrugResult(
                id=result['id'],
                name=result['metadata'].get('name', result['id']),
                smiles=result['metadata'].get('smiles', ''),
                similarity=similarity,
                distance=distance,
                indication=result['metadata'].get('indication')
            ))
        
        # Sort by similarity (descending)
        drug_results.sort(key=lambda x: x.similarity, reverse=True)
        drug_results = drug_results[:request.top_k]
        
        search_time = (time.time() - start) * 1000
        
        return DrugSearchResponse(
            query=request.smiles,
            results=drug_results,
            total_found=len(drug_results),
            search_time_ms=search_time
        )
        
    except Exception as e:
        print(f"\n[ERROR] Search failed: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Search failed: {str(e)}")


@app.post("/analyze/structure", response_model=StructuralAnalysisResponse)
def analyze_structure(smiles_list: List[str]):
    """
    STEP 2: Analyze structural features of a list of molecules
    """
    try:
        print(f"\n[ANALYSIS] Analyzing {len(smiles_list)} molecules...")
        
        analysis = analyze_structural_features(smiles_list)
        
        return StructuralAnalysisResponse(
            total_molecules=analysis["total_molecules"],
            avg_molecular_weight=analysis.get("avg_molecular_weight", 0),
            avg_ring_count=analysis.get("avg_ring_count", 0),
            avg_aromatic_rings=analysis.get("avg_aromatic_rings", 0),
            molecules_with_aromatic_rings=analysis.get("molecules_with_aromatic_rings", 0),
            molecules_with_multiple_rings=analysis.get("molecules_with_multiple_rings", 0),
            common_features=analysis.get("common_features", {})
        )
        
    except Exception as e:
        print(f"\n[ERROR] Analysis failed: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Analysis failed: {str(e)}")


@app.post("/suggest/scaffolds", response_model=ScaffoldSuggestionsResponse)
def suggest_scaffolds(request: ScaffoldSuggestionsRequest):
    """
    STEP 3: Suggest drug scaffolds based on query drugs
    """
    try:
        print(f"\n[SCAFFOLDS] Suggesting scaffolds based on {len(request.query_drugs)} query drugs...")
        
        if drugs_df.empty:
            raise HTTPException(status_code=500, detail="Drug dataset not loaded")
        
        # Convert QueryDrug models to dicts
        query_drugs_dict = [{"name": d.name, "smiles": d.smiles} for d in request.query_drugs]
        
        # Convert dataframe to list of dicts
        all_drugs = drugs_df.to_dict('records')
        
        suggestions = suggest_drug_scaffolds(
            query_drugs=query_drugs_dict,
            all_drugs=all_drugs,
            encoder=encoder,
            top_k=request.top_k
        )
        
        scaffold_list = [
            ScaffoldSuggestion(
                name=s.get('name', 'Unknown'),
                smiles=s.get('smiles', ''),
                similarity_to_centroid=s.get('similarity_to_centroid', 0),
                indication=s.get('indication')
            )
            for s in suggestions
        ]
        
        return ScaffoldSuggestionsResponse(
            suggestions=scaffold_list,
            description=f"Drugs similar to the centroid of {len(request.query_drugs)} query drugs"
        )
        
    except Exception as e:
        print(f"\n[ERROR] Scaffold suggestion failed: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Scaffold suggestion failed: {str(e)}")


@app.post("/search/use-case", response_model=DrugSearchResponse)
def search_by_use_case(request: DrugSearchByUseCaseRequest):
    """
    Search for drugs by medical use case / indication
    """
    try:
        import time
        start = time.time()
        
        if drugs_df.empty:
            return DrugSearchResponse(query=request.use_case, results=[], total_found=0)
        
        # Simple text matching in indication field
        use_case_lower = request.use_case.lower()
        matching_drugs = drugs_df[
            drugs_df['indication'].fillna('').str.lower().str.contains(use_case_lower)
        ]
        
        # Convert to DrugResult format
        results = []
        for _, row in matching_drugs.head(request.top_k).iterrows():
            results.append(DrugResult(
                id=row.get('drug_id', f"DRUG_{_}"),
                name=row.get('name', 'Unknown'),
                smiles=row.get('smiles', ''),
                similarity=1.0,
                distance=0.0,
                indication=row.get('indication')
            ))
        
        search_time = (time.time() - start) * 1000
        
        return DrugSearchResponse(
            query=request.use_case,
            results=results,
            total_found=len(results),
            search_time_ms=search_time
        )
        
    except Exception as e:
        print(f"Error in /search/use-case: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Search failed: {str(e)}")


if __name__ == "__main__":
    import uvicorn
    print("\n" + "="*60)
    print("ðŸš€ Starting Drug Discovery API - 3-Step System")
    print("="*60)
    print("\nAPI will be available at: http://localhost:8000")
    print("Docs at: http://localhost:8000/docs")
    print("\nMake sure Rust vector DB is running at http://localhost:8080")
    print("="*60 + "\n")
    
    uvicorn.run(app, host="0.0.0.0", port=8000)
